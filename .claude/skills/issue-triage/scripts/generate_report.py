#!/usr/bin/env python3
"""
Generate prioritized GitHub issue report.
Usage: python generate_report.py [output_path]

If output_path not specified, prints to stdout.
Requires: gh CLI authenticated and in a git repository.
"""

import json
import subprocess
import sys
from datetime import datetime, timezone


def get_issues():
    """Fetch open issues from GitHub."""
    result = subprocess.run(
        ["gh", "issue", "list", "--state", "open",
         "--json", "number,title,labels,createdAt,body,url",
         "--limit", "100"],
        capture_output=True, text=True
    )
    if result.returncode != 0:
        print(f"Error fetching issues: {result.stderr}", file=sys.stderr)
        sys.exit(1)
    return json.loads(result.stdout)


def get_repo_name():
    """Get repository name."""
    result = subprocess.run(
        ["gh", "repo", "view", "--json", "nameWithOwner", "-q", ".nameWithOwner"],
        capture_output=True, text=True
    )
    return result.stdout.strip() if result.returncode == 0 else "Unknown"


def calculate_age(created_at, now):
    """Calculate human-readable age."""
    created = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
    days = (now - created).days
    if days >= 60:
        return f"{days // 30}mo"
    elif days >= 14:
        return f"{days // 7}w"
    return f"{days}d"


def get_priority(labels, age_days):
    """Determine issue priority tier."""
    labels_lower = [l.lower() for l in labels]
    if 'critical' in labels_lower or 'p0' in labels_lower:
        return (0, 'ðŸ”´ Critical')
    if 'high-priority' in labels_lower or 'p1' in labels_lower:
        return (1, 'ðŸŸ  High Priority')
    if 'bug' in labels_lower and age_days > 7:
        return (2, 'ðŸŸ¡ Aging Bug')
    return (3, 'âšª Standard')


def truncate(text, max_len):
    """Truncate text with ellipsis."""
    if not text:
        return "-"
    clean = ' '.join(text.split()).replace('|', '/').replace('\n', ' ')
    return clean[:max_len] + "..." if len(clean) > max_len else clean


def generate_report(issues, repo_name, now):
    """Generate markdown report."""
    # Process and sort issues
    for issue in issues:
        labels = [l['name'] for l in issue.get('labels', [])]
        created = datetime.fromisoformat(issue['createdAt'].replace('Z', '+00:00'))
        age_days = (now - created).days
        rank, label = get_priority(labels, age_days)

        issue['_labels'] = labels
        issue['_priority_rank'] = rank
        issue['_priority'] = label
        issue['_age'] = calculate_age(issue['createdAt'], now)
        issue['_age_days'] = age_days

    issues.sort(key=lambda x: (x['_priority_rank'], -x['_age_days']))

    # Count by priority
    counts = {i: sum(1 for x in issues if x['_priority_rank'] == i) for i in range(4)}

    # Build report
    lines = [
        "# Issue Priority Report",
        "",
        f"**Generated:** {now.strftime('%Y-%m-%d %H:%M')} UTC",
        f"**Repository:** {repo_name}",
        f"**Total Open Issues:** {len(issues)}",
        "",
        "## Summary",
        "",
        "| Priority | Count |",
        "|----------|-------|",
        f"| ðŸ”´ Critical (P0) | {counts[0]} |",
        f"| ðŸŸ  High Priority (P1) | {counts[1]} |",
        f"| ðŸŸ¡ Aging Bugs (P2) | {counts[2]} |",
        f"| âšª Standard | {counts[3]} |",
        "",
        "## Prioritized Issues",
        "",
        "| # | Title | Priority | Labels | Age | Excerpt |",
        "|---|-------|----------|--------|-----|---------|",
    ]

    for issue in issues:
        num = issue['number']
        title = truncate(issue['title'], 55)
        labels = ', '.join(issue['_labels'])[:30] if issue['_labels'] else '-'
        excerpt = truncate(issue.get('body', ''), 60)
        link = f"[#{num}]({issue['url']})"
        lines.append(f"| {link} | {title} | {issue['_priority']} | {labels} | {issue['_age']} | {excerpt} |")

    lines.extend(["", "---", "*Generated by issue-triage skill*"])
    return '\n'.join(lines)


def main():
    now = datetime.now(timezone.utc)
    repo_name = get_repo_name()
    issues = get_issues()

    if not issues:
        print("No open issues found.")
        return

    report = generate_report(issues, repo_name, now)

    if len(sys.argv) > 1:
        output_path = sys.argv[1]
        with open(output_path, 'w') as f:
            f.write(report)
        print(f"âœ… Report saved to {output_path}")
        print(f"   {len(issues)} issues analyzed")
    else:
        print(report)


if __name__ == "__main__":
    main()
